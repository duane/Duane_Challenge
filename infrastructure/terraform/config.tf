terraform {
  required_providers {
    aws = {
      version = ">= 2.7.0"
      source = "hashicorp/aws"
    }
  }
}

provider "aws" {
  region = "us-west-2"
}

resource "aws_vpc" "http-demo-vpc" {}

resource "aws_security_group" "http-demo-sg" {
    egress = [
        {
            cidr_blocks = [
                "0.0.0.0/0",
            ]
            description = ""
            from_port = 0
            ipv6_cidr_blocks = []
            prefix_list_ids = []
            protocol = "-1"
            security_groups = []
            self = false
            to_port = 0
        },
    ]
    ingress = [
        {
            cidr_blocks = [
                "0.0.0.0/0",
            ]
            description = ""
            from_port = 22
            ipv6_cidr_blocks = []
            prefix_list_ids = []
            protocol = "tcp"
            security_groups = []
            self = false
            to_port = 22
        },
        {
            cidr_blocks = [
                "0.0.0.0/0",
            ]
            description = ""
            from_port = 443
            ipv6_cidr_blocks = []
            prefix_list_ids = []
            protocol = "tcp"
            security_groups = []
            self = false
            to_port = 443
        },
        {
            cidr_blocks = [
                "0.0.0.0/0",
            ]
            description = ""
            from_port = 80
            ipv6_cidr_blocks = []
            prefix_list_ids = []
            protocol = "tcp"
            security_groups = []
            self = false
            to_port = 80
        },
    ]
}

# Create a certificate for the domain.
resource "aws_acm_certificate" "http-demo-cert" {
    domain_name = "http-demo.duane.cc"
}

resource "aws_elb" "http-demo-elb" {
    availability_zones = [
        "us-west-2a",
        "us-west-2b",
    ]
    connection_draining = true
    connection_draining_timeout = 300
    cross_zone_load_balancing = true
    desync_mitigation_mode = "defensive"
    idle_timeout = 60
    instances = [
        aws_instance.demo-instance.id,
    ]
    internal = false
    name = "http-demo"
    security_groups = [
        aws_security_group.http-demo-sg.id,
    ]

    # Use the index file we uploaded for the health check, as we know that will return 200 if the server is running.
    health_check {
        healthy_threshold = 10
        interval = 5
        target = "HTTP:80/index.html"
        timeout = 2
        unhealthy_threshold = 2
    }

    # Point both HTTP and HTTPS to the same incoming port
    # Redirect will use the X-FORWARDED-PROTO header to determine if the request was HTTP or HTTPS.
    listener {
        instance_port = 80
        instance_protocol = "http"
        lb_port = 443
        lb_protocol = "https"
        ssl_certificate_id = "arn:aws:acm:us-west-2:690591551001:certificate/5ac37649-e3ff-485c-a37a-3588893d7a11"
    }
    listener {
        instance_port = 80
        instance_protocol = "http"
        lb_port = 80
        lb_protocol = "http"
    }
}

# Point the domain at the load balancer.
resource "aws_route53_record" "http-demo-record" {
  zone_id = "ZUNBDHWOSPZIR"
  name = "http-demo.duane.cc"
  type = "A"

  alias {
    name = aws_elb.http-demo-elb.dns_name
    zone_id = aws_elb.http-demo-elb.zone_id
    evaluate_target_health = true
  }
}

# Use a (locally-generated) key pair to connect to the instance.
resource "aws_key_pair" "demo-key-pair" {
    key_name = "demo-key-pair"
    public_key = file("~/.ssh/demo-key-pair.pub")
}

# and finally define the instance serving backing the load balancer with the AMI built by packer.
resource "aws_instance" "demo-instance" {
  # This is the AMI generated by the packer config.
  ami = "ami-060ab25c09f0ee869"
  instance_type = "t2.micro"
  tags = {
    Name = "demo-instance"
  }
  key_name = aws_key_pair.demo-key-pair.key_name
  vpc_security_group_ids = [
    aws_security_group.http-demo-sg.id
  ]
}
